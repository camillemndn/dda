---
title: "Outlier detection using ICS: influence of the parameters"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Outlier detection using ICS: influence of the parameters}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dpi = 300,
  fig.height = 10,
  fig.width = 15,
  fig.ext = "jpg",
  dev = "jpeg",
  dev.args = list(bg = "white")
)
```

```{r setup, message = FALSE}
library(dda)
library(tidyverse)
library(sf)
set.seed(0)
```

In this example, we filter the dataset on Vietnam temperature to
consider only the two northern regions and two provinces from
the south, from 2013 to 2016, for a total of 112 observations.

```{r vnt_north_south_map, fig.width = 9}
data(vietnam_provinces)
data(vietnam_regions)

vietnam_provinces |>
  mutate(province = if_else(region %in% c("NMM", "RRD") | province %in% c("ANGIANG", "BACLIEU"), province, NA)) |>
  left_join(vietnam_regions, by = c("region" = "code")) |>
  select(!region) |>
  rename(region = name) |>
  ggplot(aes(fill = region, label = province)) +
  geom_sf() +
  geom_sf_label(fill = "white", size = 2) +
  theme_minimal() +
  labs(x = "longitude", y = "latitude")
```

```{r vnt_north_south, fig.height = 6, fig.width = 8}
# Filter the data set
data(vietnam_temperature)
selected_years <- 2013:2016

vnt <- vietnam_temperature |>
  filter(year %in% selected_years) |>
  filter(region %in% c("NMM", "RRD") | province %in% c("ANGIANG", "BACLIEU")) |>
  left_join(vietnam_regions, by = c("region" = "code")) |>
  select(!region) |>
  rename(region = name) |>
  arrange(region, province)

vnts <- vnt |>
  mutate(t_max = as_dd(t_max,
    lambda = 1, nbasis = 12, mc.cores = 12
  ))

vnts |>
  plot_funs(t_max, color = region) +
  theme_minimal() +
  labs(x = "temperature (deg. Celsius)", y = "density")

vnts |>
  mutate(t_max = as.fd(t_max)) |>
  plot_funs(t_max, color = region) +
  theme_minimal() +
  labs(x = "temperature (deg. Celsius)", y = "clr(density)")

vnts |>
  mutate(
    t_max = as.fd(t_max),
    year = ifelse(province == "LAICHAU", year, "not LAICHAU"),
    alpha = ifelse(province == "LAICHAU", 1, 0.85)
  ) |>
  plot_funs(t_max, color = year, alpha = alpha) +
  theme_minimal() +
  labs(x = "temperature (deg. Celsius)", y = "clr(density)")
```

Let us create a grid of parameters and
define the function to call for each parameter.

```{r ics_grid}
if (!file.exists("ICS_grid_out.RData") && !file.exists("ICS_grid.RData")) {
  param_grid <- expand.grid(
    knots_pos = c("quantiles", "eq_spaced"),
    nknots = c(5:19, seq(20, nrow(vnt) - 2, 10), nrow(vnt) - 1) - 5,
    lambda = 10^(-8:8)
  ) |>
    arrange(knots_pos, nknots, lambda)

  smooth_ICS <- function(knots_pos, nknots, lambda) {
    vnts <- vnt |>
      mutate(t_max = as_dd(t_max,
        lambda = lambda, nbasis = 5 + nknots, knots_pos = knots_pos,
        mc.cores = parallel::detectCores() - 1
      ))
    knots_pos_str <- ifelse(knots_pos == "quantiles",
      "Knots at quantiles", "Equally spaced knots"
    )
    print(paste(
      "# of knots:", nknots, "|",
      "log10(lambda):", log10(lambda), "|",
      knots_pos_str
    ))

    list(
      dd = vnts$t_max,
      ics = tryCatch(ICS(as.fd(vnts$t_max)), error = function(e) e),
      ics_out = tryCatch(ICS_outlier(as.fd(vnts$t_max),
        n_cores = parallel::detectCores() - 1, index = 1:4
      ), error = function(e) e)
    )
  }

  # Smooth and detect outliers for each parameter
  system.time(
    ics_grid <- param_grid |>
      mutate(id = seq_len(n())) |>
      rowwise() |>
      mutate(res = list(smooth_ICS(knots_pos, nknots, lambda)))
  )
  save(ics_grid, file = "ICS_grid.RData")
}
```

```{r ics_grid_out_create}
if (!file.exists("ICS_grid_out.RData")) {
  load("ICS_grid.RData")

  ics_out <- ics_grid |>
    rowwise() |>
    filter(!(any(class(res$ics_out) == "error"))) |>
    mutate(res = list(as.factor(res$ics_out$outliers))) |>
    rename(outliers = res) |>
    unnest_longer(outliers, indices_to = "obs_id")
  save(ics_out, file = "ICS_grid_out.RData")
}
```

```{r ics_grid_out}
load("ICS_grid_out.RData")

ics_out |> ggplot(aes(log10(lambda), obs_id, fill = outliers)) +
  geom_tile() +
  scale_fill_grey(start = 1, end = 0) +
  facet_grid(cols = vars(nknots), rows = vars(knots_pos))
```

```{r summary}
n_grid <- 2 * 17 * 26

ics_out_freq <- ics_out |>
  mutate(outliers = ifelse(outliers == 1, 1, 0)) |>
  group_by(obs_id) |>
  summarise(n_outlier = sum(outliers)) |>
  left_join(vnt |> mutate(obs_id = row_number()), by = c("obs_id")) |>
  select(obs_id, province, year, n_outlier)

knitr::kable(ics_out_freq)

ics_out_freq |>
  ggplot(aes(obs_id, n_outlier)) +
  geom_bar(stat = "identity")

tab <- ics_out |> pivot_wider(names_from = obs_id, values_from = outliers)
tab <- apply(tab[, c(5:116)], c(1, 2), as.numeric)
library(corrplot)
corrplot(cor(tab))
```


```{r errors, include = FALSE, eval = FALSE}
ics_err <- ics_grid |>
  rowwise() |>
  mutate(ics_out = list(res$ics_out), dd = list(res$dd)) |>
  filter(any(class(ics_out) == "error")) |>
  mutate(message = case_when(
    grepl("socket", ics_out$message) ~ "socket",
    grepl("missing values", ics_out$message) ~ "collinearity",
    grepl("as.fd", ics_out$message) ~ "preprocessing",
    .default = "other"
  )) |>
  arrange(knots_pos)

ics_prob_err <- ics_out |>
  mutate(outliers = ifelse(outliers == 1, 1, 0)) |>
  group_by(id) |>
  summarise(n_outlier = sum(outliers)) |>
  arrange(desc(n_outlier))

res <- ics_grid |>
  filter(nknots < 10) |>
  #  filter(nknots == 45 & lambda == 10 & knots_pos == "eq_spaced") |>
  filter(nknots == 4 & lambda == 1e8 & knots_pos == "quantiles") |>
  sample_n(1)


ics_out1 <- res$res[[1]]$ics_out

ics_out2 <- ICS_outlier(as.fd(res$res[[1]]$dd), index = 1:4, n_cores = 14)
all(ics_out1$outliers == ics_out2$outliers)
plot(ics_out1)

qr(cov(t(to_zbsplines(c(res$res[[1]]$dd)))))
eigen(cov(t(to_zbsplines(c(res$res[[1]]$dd)))))$values
```

