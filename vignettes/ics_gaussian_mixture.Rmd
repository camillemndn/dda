---
title: "ICS on Mixture of Gaussian Processes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ICS on Mixture of Gaussian Processes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dda)
library(fda.usc)
library(ggplot2)
library(GGally)
```

## Mixture of Gaussian processes for functional data

Let us sample functional data from a squared exponential kernel gaussian process,
and then contaminate it with the same GP, but with a different mean.

```{r}
# Covariance function (e.g., squared exponential kernel)
cov_sqexp <- function(x1, x2) exp(-0.5 * (x1 - x2)^2)

grid <- seq(0, 1, 0.01)
contour(grid, grid, outer(grid, grid, cov_sqexp),
  main = "Contour Plot", xlab = "x", ylab = "y",
  levels = seq(-1, 1, by = 0.1),
  col = terrain.colors(length(seq(-1, 1, by = 0.1)))
)

eps <- 0.1
n <- 100
t <- seq(0, 10, 0.01)

x1 <- rproc2fdata(n, t,
  sigma = outer(t, t, cov_sqexp)
)
x2 <- rproc2fdata(round(eps * n), t,
  mu = 5 + sin(3 * t),
  sigma = outer(t, t, cov_sqexp)
)

# Contamination
x1$data[1:round(eps * n), ] <- x2$data
plot(x1)
```

```{r}
x1_pc <- create.pc.basis(x1, l = 1:20, lambda = 1)
plot(x1_pc$fdata.est - x1)
plot(x1_pc$basis)
```

## Mixture of Gaussian processes for distributional data

From the previously sampled functional data, there a multiple ways
to send it to the Bayes space.

### First option: densities of the ordinates

```{r}
x1d <- dda:::merge.dd(as.list(apply(
  x1$data, 1,
  function(...) density(rangeval = range(x1), ...)
)))
plot(x1d)
```

The curves seem closer to temperature densities in Vietnam.
The outliers are horizontally shifted.

```{r}
x1_out <- as.factor(c(rep(0, 10), rep(1, 90)))
ggpairs(as.data.frame(ICS(x1d)$scores),
  columns = 1:9, diag = "blank",
  aes(label = 1:n, color = x1_out)
) + geom_text()

plot(ICS(x1d)$W[1])
```

### Second option: log-densities

Each function has its temporal mean substracted so it
can represent the clr of a density.

```{r}
x1dlog <- density(clr = fdata2fd(x1, nbasis = 11))
x1dlog$coefs <- sweep(x1dlog$coefs, 2, 0.1 * inprod(x1dlog))
plot.fd(x1dlog, col = 3 - as.numeric(x1_out))
```

The outliers are quite invisible.

```{r}
plot(ICS(x1dlog)$W[1])
ggpairs(as.data.frame(ICS(x1dlog)$scores),
  diag = "blank",
  aes(label = 1:n, color = x1_out)
) + geom_text()
```

### Conclusions

Compared with the first option, the second option:

- seems less relevant to the data generating process (too many modes)
- but dICS works better on it as it is (ICS on the ZB-splines coordinates)

Maybe a different covariance kernel can yield densities with less modes.

Other option: to find an isometry from $L^2$ to $L^2_0$.
